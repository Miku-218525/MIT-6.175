1.无符号乘法和有符号乘法不一样，但未在测试台运行
  
2.删除function Bit#(16)。。。后编译代码错误可能是：缺少16这个参数，即Bit#(TAdd#(n,n))；
  修复错误的方式：通过定义具体的函数来传入这个参数；
  不需要同时定义两个函数是因为：另一个函数的n的值由编译器根据传入参数的大小自行判断。

3.multiply_by_adding的实现是无符号乘法器，因为只在加，不会出现负数的情况。

4.
Current Bits | Previous Bit | Original Booth Encoding | Radix-4 Booth Encoding
-------------+--------------+-------------------------+-----------------------
    00       |      0       |           00            |         00  
    00       |      1       |           0+            |         0+  
    01       |      0       |           +-            |         0+
    01       |      1       |           +0            |         +0  
    10       |      0       |           -0            |         -0  
    10       |      1       |           -+            |         0-  
    11       |      0       |           0-            |         0-  
    11       |      1       |           00            |         00  

5.并不是所有radix-8 Booth编码都可以只用一个非零符号表示，最后得到的Radix-8 Booth Encoding应该包括：
  000，
  00+、00-，0+0、0-0，+00、-00，
  0++、0--
  可能更多，但上边列的最后两种必然存在，已经用了两个非零符号了。

6.忘了（中间隔了一个月）
